name: 'nobrainer.host'
description: 'Zero-config deployment for web apps (static and Docker) with automatic subdomain routing and SSL'
author: 'Daniel Vassallo'

branding:
  icon: 'upload-cloud'
  color: 'blue'

inputs:
  domain:
    description: 'Your domain name (e.g., example.com)'
    required: true
  server:
    description: 'Server IP or hostname for SSH (defaults to domain if not set)'
    required: false
    default: ''
  deploy_key:
    description: 'SSH private key for server access'
    required: true
  letsencrypt_email:
    description: 'Email for Let''s Encrypt SSL certificate notifications (optional)'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Set up SSH
      shell: bash
      run: |
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        mkdir -p ~/.ssh
        echo "${{ inputs.deploy_key }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts

    - name: Run server setup (idempotent)
      shell: bash
      run: |
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        echo "Running server setup for domain: ${{ inputs.domain }} (via $SSH_HOST)"
        
        # Copy setup files from the action's directory to server
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          ${{ github.action_path }}/server-setup/setup.sh \
          ${{ github.action_path }}/server-setup/nginx-apps.conf \
          root@$SSH_HOST:/tmp/
        
        # Run setup script (idempotent - skips already-completed steps)
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@$SSH_HOST \
          "chmod +x /tmp/setup.sh && /tmp/setup.sh ${{ inputs.domain }} ${{ inputs.letsencrypt_email }}"

    - name: Generate app index
      shell: bash
      run: |
        # Skip if user has a custom _root/index.html (not a template)
        if [ -f "_root/index.html" ] && [ ! -f "_root/index.template.html" ]; then
          echo "Custom _root/index.html found, skipping generation"
          exit 0
        fi
        
        DOMAIN="${{ inputs.domain }}"
        
        # Find all app directories (exclude system folders)
        APPS=$(find . -maxdepth 1 -type d \
          ! -name '.' \
          ! -name '.git' \
          ! -name '.github' \
          ! -name 'server-setup' \
          ! -name '_root' \
          -printf '%f\n' | sort)
        
        # Generate app links HTML
        APP_COUNT=0
        APP_LINKS=""
        for app in $APPS; do
            APP_LINKS="${APP_LINKS}<a href=\"https://${app}.${DOMAIN}\">${app}</a>\n"
            APP_COUNT=$((APP_COUNT + 1))
        done
        
        # Handle empty state
        if [ $APP_COUNT -eq 0 ]; then
            APP_LINKS='<p class="empty">No apps deployed yet.</p>'
        fi
        
        mkdir -p _root
        
        # Check if user has a template
        if [ -f "_root/index.template.html" ]; then
          echo "Using custom template _root/index.template.html"
          # Replace placeholders in template
          sed -e "s|{{APPS}}|${APP_LINKS}|g" \
              -e "s|{{APP_COUNT}}|${APP_COUNT}|g" \
              -e "s|{{DOMAIN}}|${DOMAIN}|g" \
              _root/index.template.html > _root/index.html
        else
          # Use default template
          cat > _root/index.html << HTMLEOF
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Apps</title>
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body {
                    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
                    min-height: 100vh;
                    background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
                    color: #e8e8e8;
                    padding: 3rem 1.5rem;
                }
                .container {
                    max-width: 600px;
                    margin: 0 auto;
                }
                h1 {
                    font-size: 2.5rem;
                    font-weight: 600;
                    margin-bottom: 2rem;
                    background: linear-gradient(135deg, #00d9ff, #00ff88);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    background-clip: text;
                }
                .apps {
                    display: flex;
                    flex-direction: column;
                    gap: 0.75rem;
                }
                a {
                    display: block;
                    padding: 1rem 1.25rem;
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.08);
                    border-radius: 12px;
                    color: #fff;
                    text-decoration: none;
                    font-size: 1.1rem;
                    transition: all 0.2s ease;
                }
                a:hover {
                    background: rgba(255, 255, 255, 0.08);
                    border-color: rgba(0, 217, 255, 0.3);
                    transform: translateX(4px);
                }
                .empty {
                    color: rgba(255, 255, 255, 0.5);
                    font-style: italic;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Apps</h1>
                <div class="apps">
                    ${APP_LINKS}
                </div>
            </div>
        </body>
        </html>
        HTMLEOF
        fi
        
        echo "Generated index with $APP_COUNT apps"

    - name: Update helper scripts on server
      shell: bash
      run: |
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        # Always update ensure-cert.sh to latest version
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          ${{ github.action_path }}/server-setup/setup.sh \
          root@$SSH_HOST:/tmp/setup.sh
        
        # Extract and update just the ensure-cert.sh script
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@$SSH_HOST << 'SCRIPT'
        # Update ensure-cert.sh with permission fixes
        cat > /usr/local/bin/ensure-cert.sh << 'CERTSCRIPT'
        #!/bin/bash
        set -e
        SUBDOMAIN=$1
        DOMAIN=$2
        EMAIL=${3:-}

        if [ -z "$SUBDOMAIN" ] || [ -z "$DOMAIN" ]; then
            echo "Usage: ensure-cert.sh <subdomain> <domain> [email]"
            exit 1
        fi

        if [ -n "$EMAIL" ]; then
            CERTBOT_EMAIL_ARG="--email $EMAIL"
        else
            CERTBOT_EMAIL_ARG="--register-unsafely-without-email"
        fi

        FQDN="${SUBDOMAIN}.${DOMAIN}"
        CERT_PATH="/etc/letsencrypt/live/${FQDN}"

        if [ -d "$CERT_PATH" ]; then
            echo "Certificate already exists for ${FQDN}"
            exit 0
        fi

        echo "Obtaining certificate for ${FQDN}..."
        certbot certonly \
            --webroot \
            --webroot-path /var/www/acme-challenge \
            -d "$FQDN" \
            $CERTBOT_EMAIL_ARG \
            --agree-tos \
            --non-interactive \
            --quiet

        if [ $? -eq 0 ]; then
            echo "Certificate obtained successfully for ${FQDN}"
            chmod 755 /etc/letsencrypt/live/
            chmod 755 /etc/letsencrypt/archive/
            chmod 644 /etc/letsencrypt/archive/${FQDN}/*.pem 2>/dev/null || true
            exit 0
        else
            echo "Failed to obtain certificate for ${FQDN}"
            exit 1
        fi
        CERTSCRIPT
        chmod +x /usr/local/bin/ensure-cert.sh
        SCRIPT

    - name: Deploy apps via rsync
      shell: bash
      run: |
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        rsync -avz --delete \
          --exclude '.git' \
          --exclude '.github' \
          --exclude 'server-setup' \
          --exclude 'README.md' \
          --exclude 'LICENSE' \
          --exclude '.gitignore' \
          --exclude '*.md' \
          -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
          ./ root@$SSH_HOST:/var/www/apps/

    - name: Detect and start docker apps
      id: docker_apps
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        # Find docker apps (folders with docker-compose.yml), sorted alphabetically
        DOCKER_APPS=$(find . -maxdepth 2 -name "docker-compose.yml" -printf '%h\n' | sed 's|^\./||' | sort)
        
        # Assign ports starting at 3000
        PORT=3000
        DOCKER_APP_PORTS=""
        
        for app in $DOCKER_APPS; do
          echo "Starting docker app: $app on port $PORT"
          
          # Start the docker app on the server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@$SSH_HOST \
            "cd /var/www/apps/$app && PORT=$PORT docker compose up -d --build --remove-orphans" || true
          
          # Track app:port mapping
          DOCKER_APP_PORTS="${DOCKER_APP_PORTS}${app}:${PORT}\n"
          PORT=$((PORT + 1))
        done
        
        # Save docker app ports for nginx config generation
        echo -e "$DOCKER_APP_PORTS" > /tmp/docker_app_ports.txt
        echo "docker_apps=$DOCKER_APPS" >> $GITHUB_OUTPUT
        
        if [ -n "$DOCKER_APPS" ]; then
          echo "Started docker apps: $DOCKER_APPS"
        else
          echo "No docker apps found"
        fi

    - name: Stop orphaned docker containers
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        # Stop docker containers whose project name doesn't match any app folder
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@$SSH_HOST << 'CLEANUP_DOCKER'
        
        # Get all docker-compose project names from running containers
        PROJECTS=$(docker ps --format '{{.Labels}}' 2>/dev/null | grep -oP 'com.docker.compose.project=\K[^,]+' | sort -u || true)
        
        for project in $PROJECTS; do
          # Check if app folder still exists
          if [ ! -d "/var/www/apps/$project" ]; then
            echo "Stopping orphaned docker app: $project"
            cd /var/www/apps 2>/dev/null || true
            docker compose -p "$project" down --remove-orphans 2>/dev/null || true
          fi
        done
        
        echo "Orphaned docker container cleanup complete"
        CLEANUP_DOCKER

    - name: Issue SSL certificates for apps
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        EMAIL="${{ inputs.letsencrypt_email }}"
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        # Find all app directories
        APPS=$(find . -maxdepth 1 -type d \
          ! -name '.' \
          ! -name '.git' \
          ! -name '.github' \
          ! -name 'server-setup' \
          ! -name '_root' \
          -printf '%f\n' | sort)
        
        CERTS_ISSUED=0
        for app in $APPS; do
          echo "Ensuring certificate for ${app}.${DOMAIN}..."
          
          # Run ensure-cert.sh on the server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@$SSH_HOST \
            "/usr/local/bin/ensure-cert.sh $app $DOMAIN $EMAIL" && CERTS_ISSUED=$((CERTS_ISSUED + 1)) || true
        done
        
        echo "Processed certificates for $CERTS_ISSUED apps"

    - name: Fix certificate permissions
      shell: bash
      run: |
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        # Fix permissions for ALL certs so nginx workers can read them
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@$SSH_HOST << 'FIXPERMS'
        echo "Fixing certificate permissions..."
        chmod 755 /etc/letsencrypt/live/ 2>/dev/null || true
        chmod 755 /etc/letsencrypt/archive/ 2>/dev/null || true
        find /etc/letsencrypt/archive/ -name "*.pem" -exec chmod 644 {} \; 2>/dev/null || true
        echo "Certificate permissions fixed"
        FIXPERMS

    - name: Clean up orphaned certificates
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"
        
        # Get list of certs on server and clean up orphaned ones
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@$SSH_HOST << CLEANUP_SCRIPT
        
        # Find all subdomain certs (exclude root domain cert)
        for cert_dir in /etc/letsencrypt/live/*.${DOMAIN}; do
          [ -d "\$cert_dir" ] || continue
          
          cert_name=\$(basename "\$cert_dir")
          # Extract subdomain (remove .domain.com suffix)
          subdomain=\${cert_name%.${DOMAIN}}
          
          # Check if this subdomain still exists as a deployed app
          if [ ! -d "/var/www/apps/\$subdomain" ]; then
            echo "Removing orphaned certificate for \$cert_name..."
            certbot delete --cert-name "\$cert_name" --non-interactive || true
          fi
        done
        CLEANUP_SCRIPT
        
        echo "Orphaned certificate cleanup complete"

    - name: Generate and update nginx config
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        SSH_HOST="${{ inputs.server }}"
        [ -z "$SSH_HOST" ] && SSH_HOST="${{ inputs.domain }}"

        # Find all apps
        ALL_APPS=$(find . -maxdepth 1 -type d \
          ! -name '.' \
          ! -name '.git' \
          ! -name '.github' \
          ! -name 'server-setup' \
          ! -name '_root' \
          -printf '%f\n' | sort)

        # Find docker apps
        DOCKER_APPS=$(find . -maxdepth 2 -name "docker-compose.yml" -printf '%h\n' | sed 's|^\./||' | sort)

        # Query server for which SSL certificates actually exist
        EXISTING_CERTS=$(ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no root@$SSH_HOST \
          "ls -d /etc/letsencrypt/live/*.$DOMAIN 2>/dev/null | xargs -I{} basename {} | sort" || true)

        # Create nginx config file locally
        cat > /tmp/nginx-apps.conf << NGINXEOF
        # HTTP - ACME challenges and redirect to HTTPS
        server {
            listen 80;
            listen [::]:80;
            server_name *.$DOMAIN $DOMAIN;
            location /.well-known/acme-challenge/ { root /var/www/acme-challenge; }
            location / { return 301 https://\$host\$request_uri; }
        }
        # Root domain
        server {
            listen 443 ssl http2;
            listen [::]:443 ssl http2;
            server_name $DOMAIN;
            ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_prefer_server_ciphers off;
            root /var/www/apps/_root;
            index index.html;
            location / { try_files \$uri \$uri/ =404; }
        }
        NGINXEOF

        # Generate config for each app
        PORT=3000
        SKIPPED_APPS=""
        for app in $ALL_APPS; do
          # Check if SSL certificate exists on the server for this app
          CERT_FQDN="$app.$DOMAIN"
          if ! echo "$EXISTING_CERTS" | grep -qx "$CERT_FQDN"; then
            echo "WARNING: No SSL certificate found for $CERT_FQDN, skipping nginx config"
            SKIPPED_APPS="${SKIPPED_APPS} ${app}"
            # Still increment port for docker apps to keep port assignment stable
            for docker_app in $DOCKER_APPS; do
              if [ "$app" = "$docker_app" ]; then
                PORT=$((PORT + 1))
                break
              fi
            done
            continue
          fi

          IS_DOCKER=false
          for docker_app in $DOCKER_APPS; do
            if [ "$app" = "$docker_app" ]; then
              IS_DOCKER=true
              break
            fi
          done

          if [ "$IS_DOCKER" = true ]; then
            cat >> /tmp/nginx-apps.conf << APPEOF
        # Docker app - $app -> port $PORT
        server {
            listen 443 ssl http2;
            listen [::]:443 ssl http2;
            server_name $app.$DOMAIN;
            ssl_certificate /etc/letsencrypt/live/$app.$DOMAIN/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/$app.$DOMAIN/privkey.pem;
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_prefer_server_ciphers off;
            location / {
                proxy_pass http://127.0.0.1:$PORT;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_cache_bypass \$http_upgrade;
            }
        }
        APPEOF
            PORT=$((PORT + 1))
          else
            cat >> /tmp/nginx-apps.conf << APPEOF
        # Static app - $app
        server {
            listen 443 ssl http2;
            listen [::]:443 ssl http2;
            server_name $app.$DOMAIN;
            ssl_certificate /etc/letsencrypt/live/$app.$DOMAIN/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/$app.$DOMAIN/privkey.pem;
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_prefer_server_ciphers off;
            root /var/www/apps/$app;
            index index.html index.htm;
            add_header X-Frame-Options "SAMEORIGIN" always;
            add_header X-Content-Type-Options "nosniff" always;
            gzip on;
            gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
            location / { try_files \$uri \$uri/ /index.html =404; }
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                expires 30d;
                add_header Cache-Control "public, immutable";
            }
        }
        APPEOF
          fi
        done

        if [ -n "$SKIPPED_APPS" ]; then
          echo "WARNING: Skipped apps with missing certificates:$SKIPPED_APPS"
        fi

        # Copy config to server and reload nginx
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no /tmp/nginx-apps.conf root@$SSH_HOST:/etc/nginx/sites-available/apps
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no root@$SSH_HOST \
          "ln -sf /etc/nginx/sites-available/apps /etc/nginx/sites-enabled/apps && nginx -t && systemctl reload nginx"
        echo "Nginx config updated and reloaded"

    - name: Clean up SSH key
      shell: bash
      run: rm -f ~/.ssh/deploy_key

