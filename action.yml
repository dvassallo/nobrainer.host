name: 'nobrainer.host'
description: 'Zero-config deployment for web apps (static and Docker) with automatic subdomain routing and SSL'
author: 'Daniel Vassallo'

branding:
  icon: 'upload-cloud'
  color: 'blue'

inputs:
  domain:
    description: 'Your domain name (e.g., example.com)'
    required: true
  deploy_key:
    description: 'SSH private key for server access'
    required: true
  letsencrypt_email:
    description: 'Email for Let''s Encrypt SSL certificate notifications'
    required: true
  force_setup:
    description: 'Force re-run server setup even if already configured'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Set up SSH
      shell: bash
      run: |
        mkdir -p ~/.ssh
        echo "${{ inputs.deploy_key }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ inputs.domain }} >> ~/.ssh/known_hosts

    - name: Check if server needs setup
      id: check_setup
      shell: bash
      run: |
        SETUP_DONE=$(ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} \
          "test -f /usr/local/bin/ensure-cert.sh && test -d /etc/letsencrypt/live/${{ inputs.domain }} && command -v docker >/dev/null 2>&1 && echo 'yes' || echo 'no'")
        
        echo "setup_done=$SETUP_DONE" >> $GITHUB_OUTPUT
        
        if [ "$SETUP_DONE" = "yes" ]; then
          echo "✓ Server is already set up"
        else
          echo "→ Server needs setup"
        fi

    - name: Run server setup
      if: steps.check_setup.outputs.setup_done == 'no' || inputs.force_setup == 'true'
      shell: bash
      run: |
        echo "Setting up server for domain: ${{ inputs.domain }}"
        
        # Copy setup files from the action's directory to server
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          ${{ github.action_path }}/server-setup/setup.sh \
          ${{ github.action_path }}/server-setup/nginx-apps.conf \
          root@${{ inputs.domain }}:/tmp/
        
        # Run setup script
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} \
          "chmod +x /tmp/setup.sh && /tmp/setup.sh ${{ inputs.domain }} ${{ inputs.letsencrypt_email }}"

    - name: Generate app index
      shell: bash
      run: |
        # Skip if user has a custom _root/index.html (not a template)
        if [ -f "_root/index.html" ] && [ ! -f "_root/index.template.html" ]; then
          echo "Custom _root/index.html found, skipping generation"
          exit 0
        fi
        
        DOMAIN="${{ inputs.domain }}"
        
        # Find all app directories (exclude system folders)
        APPS=$(find . -maxdepth 1 -type d \
          ! -name '.' \
          ! -name '.git' \
          ! -name '.github' \
          ! -name 'server-setup' \
          ! -name '_root' \
          -printf '%f\n' | sort)
        
        # Generate app links HTML
        APP_COUNT=0
        APP_LINKS=""
        for app in $APPS; do
            APP_LINKS="${APP_LINKS}<a href=\"https://${app}.${DOMAIN}\">${app}</a>\n"
            APP_COUNT=$((APP_COUNT + 1))
        done
        
        # Handle empty state
        if [ $APP_COUNT -eq 0 ]; then
            APP_LINKS='<p class="empty">No apps deployed yet.</p>'
        fi
        
        mkdir -p _root
        
        # Check if user has a template
        if [ -f "_root/index.template.html" ]; then
          echo "Using custom template _root/index.template.html"
          # Replace placeholders in template
          sed -e "s|{{APPS}}|${APP_LINKS}|g" \
              -e "s|{{APP_COUNT}}|${APP_COUNT}|g" \
              -e "s|{{DOMAIN}}|${DOMAIN}|g" \
              _root/index.template.html > _root/index.html
        else
          # Use default template
          cat > _root/index.html << HTMLEOF
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Apps</title>
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body {
                    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
                    min-height: 100vh;
                    background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
                    color: #e8e8e8;
                    padding: 3rem 1.5rem;
                }
                .container {
                    max-width: 600px;
                    margin: 0 auto;
                }
                h1 {
                    font-size: 2.5rem;
                    font-weight: 600;
                    margin-bottom: 2rem;
                    background: linear-gradient(135deg, #00d9ff, #00ff88);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    background-clip: text;
                }
                .apps {
                    display: flex;
                    flex-direction: column;
                    gap: 0.75rem;
                }
                a {
                    display: block;
                    padding: 1rem 1.25rem;
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.08);
                    border-radius: 12px;
                    color: #fff;
                    text-decoration: none;
                    font-size: 1.1rem;
                    transition: all 0.2s ease;
                }
                a:hover {
                    background: rgba(255, 255, 255, 0.08);
                    border-color: rgba(0, 217, 255, 0.3);
                    transform: translateX(4px);
                }
                .empty {
                    color: rgba(255, 255, 255, 0.5);
                    font-style: italic;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Apps</h1>
                <div class="apps">
                    ${APP_LINKS}
                </div>
            </div>
        </body>
        </html>
        HTMLEOF
        fi
        
        echo "Generated index with $APP_COUNT apps"

    - name: Update helper scripts on server
      shell: bash
      run: |
        # Always update ensure-cert.sh to latest version
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          ${{ github.action_path }}/server-setup/setup.sh \
          root@${{ inputs.domain }}:/tmp/setup.sh
        
        # Extract and update just the ensure-cert.sh script
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} << 'SCRIPT'
        # Update ensure-cert.sh with permission fixes
        cat > /usr/local/bin/ensure-cert.sh << 'CERTSCRIPT'
        #!/bin/bash
        set -e
        SUBDOMAIN=$1
        DOMAIN=$2
        EMAIL=$3
        
        if [ -z "$SUBDOMAIN" ] || [ -z "$DOMAIN" ] || [ -z "$EMAIL" ]; then
            echo "Usage: ensure-cert.sh <subdomain> <domain> <email>"
            exit 1
        fi
        
        FQDN="${SUBDOMAIN}.${DOMAIN}"
        CERT_PATH="/etc/letsencrypt/live/${FQDN}"
        
        if [ -d "$CERT_PATH" ]; then
            echo "Certificate already exists for ${FQDN}"
            exit 0
        fi
        
        echo "Obtaining certificate for ${FQDN}..."
        certbot certonly \
            --webroot \
            --webroot-path /var/www/acme-challenge \
            -d "$FQDN" \
            --email "$EMAIL" \
            --agree-tos \
            --non-interactive \
            --quiet
        
        if [ $? -eq 0 ]; then
            echo "Certificate obtained successfully for ${FQDN}"
            chmod 755 /etc/letsencrypt/live/
            chmod 755 /etc/letsencrypt/archive/
            chmod 644 /etc/letsencrypt/archive/${FQDN}/*.pem 2>/dev/null || true
            exit 0
        else
            echo "Failed to obtain certificate for ${FQDN}"
            exit 1
        fi
        CERTSCRIPT
        chmod +x /usr/local/bin/ensure-cert.sh
        SCRIPT

    - name: Deploy apps via rsync
      shell: bash
      run: |
        rsync -avz --delete \
          --exclude '.git' \
          --exclude '.github' \
          --exclude 'server-setup' \
          --exclude 'README.md' \
          --exclude 'LICENSE' \
          --exclude '.gitignore' \
          --exclude '*.md' \
          -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
          ./ root@${{ inputs.domain }}:/var/www/apps/

    - name: Detect and start docker apps
      id: docker_apps
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        
        # Find docker apps (folders with docker-compose.yml), sorted alphabetically
        DOCKER_APPS=$(find . -maxdepth 2 -name "docker-compose.yml" -printf '%h\n' | sed 's|^\./||' | sort)
        
        # Assign ports starting at 3000
        PORT=3000
        DOCKER_APP_PORTS=""
        
        for app in $DOCKER_APPS; do
          echo "Starting docker app: $app on port $PORT"
          
          # Start the docker app on the server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ inputs.domain }} \
            "cd /var/www/apps/$app && PORT=$PORT docker compose up -d --build --remove-orphans" || true
          
          # Track app:port mapping
          DOCKER_APP_PORTS="${DOCKER_APP_PORTS}${app}:${PORT}\n"
          PORT=$((PORT + 1))
        done
        
        # Save docker app ports for nginx config generation
        echo -e "$DOCKER_APP_PORTS" > /tmp/docker_app_ports.txt
        echo "docker_apps=$DOCKER_APPS" >> $GITHUB_OUTPUT
        
        if [ -n "$DOCKER_APPS" ]; then
          echo "Started docker apps: $DOCKER_APPS"
        else
          echo "No docker apps found"
        fi

    - name: Stop orphaned docker containers
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        
        # Stop docker containers whose project name doesn't match any app folder
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} << 'CLEANUP_DOCKER'
        
        # Get all docker-compose project names from running containers
        PROJECTS=$(docker ps --format '{{.Labels}}' 2>/dev/null | grep -oP 'com.docker.compose.project=\K[^,]+' | sort -u || true)
        
        for project in $PROJECTS; do
          # Check if app folder still exists
          if [ ! -d "/var/www/apps/$project" ]; then
            echo "Stopping orphaned docker app: $project"
            cd /var/www/apps 2>/dev/null || true
            docker compose -p "$project" down --remove-orphans 2>/dev/null || true
          fi
        done
        
        echo "Orphaned docker container cleanup complete"
        CLEANUP_DOCKER

    - name: Issue SSL certificates for apps
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        EMAIL="${{ inputs.letsencrypt_email }}"
        
        # Find all app directories
        APPS=$(find . -maxdepth 1 -type d \
          ! -name '.' \
          ! -name '.git' \
          ! -name '.github' \
          ! -name 'server-setup' \
          ! -name '_root' \
          -printf '%f\n' | sort)
        
        CERTS_ISSUED=0
        for app in $APPS; do
          echo "Ensuring certificate for ${app}.${DOMAIN}..."
          
          # Run ensure-cert.sh on the server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ inputs.domain }} \
            "/usr/local/bin/ensure-cert.sh $app $DOMAIN $EMAIL" && CERTS_ISSUED=$((CERTS_ISSUED + 1)) || true
        done
        
        echo "Processed certificates for $CERTS_ISSUED apps"

    - name: Fix certificate permissions
      shell: bash
      run: |
        # Fix permissions for ALL certs so nginx workers can read them
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} << 'FIXPERMS'
        echo "Fixing certificate permissions..."
        chmod 755 /etc/letsencrypt/live/ 2>/dev/null || true
        chmod 755 /etc/letsencrypt/archive/ 2>/dev/null || true
        find /etc/letsencrypt/archive/ -name "*.pem" -exec chmod 644 {} \; 2>/dev/null || true
        echo "Certificate permissions fixed"
        FIXPERMS

    - name: Clean up orphaned certificates
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        
        # Get list of certs on server and clean up orphaned ones
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} << CLEANUP_SCRIPT
        
        # Find all subdomain certs (exclude root domain cert)
        for cert_dir in /etc/letsencrypt/live/*.${DOMAIN}; do
          [ -d "\$cert_dir" ] || continue
          
          cert_name=\$(basename "\$cert_dir")
          # Extract subdomain (remove .domain.com suffix)
          subdomain=\${cert_name%.${DOMAIN}}
          
          # Check if this subdomain still exists as a deployed app
          if [ ! -d "/var/www/apps/\$subdomain" ]; then
            echo "Removing orphaned certificate for \$cert_name..."
            certbot delete --cert-name "\$cert_name" --non-interactive || true
          fi
        done
        CLEANUP_SCRIPT
        
        echo "Orphaned certificate cleanup complete"

    - name: Generate and update nginx config
      shell: bash
      run: |
        DOMAIN="${{ inputs.domain }}"
        
        # Find all apps
        ALL_APPS=$(find . -maxdepth 1 -type d \
          ! -name '.' \
          ! -name '.git' \
          ! -name '.github' \
          ! -name 'server-setup' \
          ! -name '_root' \
          -printf '%f\n' | sort)
        
        # Find docker apps
        DOCKER_APPS=$(find . -maxdepth 2 -name "docker-compose.yml" -printf '%h\n' | sed 's|^\./||' | sort)
        
        # Build nginx config dynamically
        NGINX_CONFIG=""
        
        # HTTP server for ACME challenges and redirect
        NGINX_CONFIG+="# HTTP - ACME challenges and redirect to HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name *.${DOMAIN} ${DOMAIN};
    
    location /.well-known/acme-challenge/ {
        root /var/www/acme-challenge;
    }
    
    location / {
        return 301 https://\\\$host\\\$request_uri;
    }
}

"
        
        # Root domain server
        NGINX_CONFIG+="# Root domain
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${DOMAIN};
    
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    
    root /var/www/apps/_root;
    index index.html;
    
    location / {
        try_files \\\$uri \\\$uri/ =404;
    }
}

"
        
        # Generate config for each app
        PORT=3000
        for app in $ALL_APPS; do
          # Check if it's a docker app
          IS_DOCKER=false
          for docker_app in $DOCKER_APPS; do
            if [ "$app" = "$docker_app" ]; then
              IS_DOCKER=true
              break
            fi
          done
          
          if [ "$IS_DOCKER" = true ]; then
            # Docker app - proxy to port
            NGINX_CONFIG+="# Docker app: ${app} -> port ${PORT}
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${app}.${DOMAIN};
    
    ssl_certificate /etc/letsencrypt/live/${app}.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${app}.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    
    location / {
        proxy_pass http://127.0.0.1:${PORT};
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \\\$host;
        proxy_set_header X-Real-IP \\\$remote_addr;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\\$scheme;
        proxy_cache_bypass \\\$http_upgrade;
    }
}

"
            PORT=$((PORT + 1))
          else
            # Static app - serve files
            NGINX_CONFIG+="# Static app: ${app}
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${app}.${DOMAIN};
    
    ssl_certificate /etc/letsencrypt/live/${app}.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${app}.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    
    root /var/www/apps/${app};
    index index.html index.htm;
    
    add_header X-Frame-Options \"SAMEORIGIN\" always;
    add_header X-Content-Type-Options \"nosniff\" always;
    
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
    
    location / {
        try_files \\\$uri \\\$uri/ /index.html =404;
    }
    
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)\$ {
        expires 30d;
        add_header Cache-Control \"public, immutable\";
    }
}

"
          fi
        done
        
        # Write and apply nginx config
        echo "$NGINX_CONFIG" | ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} "cat > /etc/nginx/sites-available/apps"
        
        # Enable and reload nginx
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          root@${{ inputs.domain }} \
          "ln -sf /etc/nginx/sites-available/apps /etc/nginx/sites-enabled/apps && \
           nginx -t && systemctl reload nginx"
        
        echo "Nginx config updated and reloaded"

    - name: Clean up SSH key
      shell: bash
      run: rm -f ~/.ssh/deploy_key

